The codegenerator uses translation rules to generate machine code from a decorated AST. These rules can be defined in StringTemplate, a templating engine used by ANTLR. In our implementation, these rules are rendered using StringTemplate. The StringTemplate group files are located under \texttt{src/st}.

\lstset{
mathescape = true
}

\section{Program}
\begin{lstlisting}
run[S*] =
  class_header
  foreach $S_i$ in S:
    execute $S_i$
  class_footer
\end{lstlisting}  
A program is a sequence of statements. First, a header is emitted that is required by the class format, then the statements are executed and finally a class footer is emitted.

\begin{lstlisting}
class_header[name] =
  .class public [$name$]
  .super java/lang/Object

  .method public static main([Ljava/lang/String;)V
    .limit stack 	512
    .limit locals 	512
\end{lstlisting}


\begin{lstlisting}
class_footer[] =
  return
  .end method
  readFunctions[]
\end{lstlisting}

The code function read_functions is rather verbose. The read functions are generated by writing these code functions in Java and compiling them to JVM bytecode. this file is then disassembled and the assembly instruction are included as the code function \texttt{readFunctions}. The following Java functions were written for the read functions:

\lstinputlisting[language=Java,
aboveskip=3mm,
belowskip=3mm,
showstringspaces=false,
columns=flexible,
basicstyle={\small\ttfamily},
numbers=none,
numberstyle=\tiny\color{gray},
keywordstyle=\color{blue},
commentstyle=\color{dkgreen},
stringstyle=\color{mauve},
breaklines=true,
breakatwhitespace=true
]{text/codefunction/readfunctions.tex}


\section{Statement}
\begin{lstlisting}
execute[D] = 
  elaborate D
\end{lstlisting}

A declaration statement simply elaborates the declaration.

\begin{lstlisting}
execute[E] = 
  evaluate E
  pop			if type(E) not Void
\end{lstlisting}

An expression statement first evaluates the expression. When the type of the expression is not Void, the result is popped off the stack prevent unused values from staying on the stack.
  
\section{Declaration}
\begin{lstlisting}
elaborate[var I : T] = 	
  iconst_0
  istore i		where i = variable offset of I
\end{lstlisting}

A variable declaration initializes the variable with the zero value of that type. The variable offset is determined in the context checking phase.

\begin{lstlisting}
elaborate[const I = E] =  if E cannot be computed at compile time
  evaluate E		
  istore i		where i = variable offset of I
\end{lstlisting}

A constant declaration only generates code when a constant cannot be computed at compile time. Whenever such a constant is declared, the constant expression is evaluated and assigned to variable I at the given offset.

\section{Expression}
\begin{lstlisting}
evaluate[N]
  ldc i			where i = integer value of N
\end{lstlisting}
An integer constant pushes its integer value on the stack

\begin{lstlisting}  
evaluate[C]
  ldc c			where c = integer code of C
\end{lstlisting}
A Character constant pushes the charcode of the Character on the stack

\begin{lstlisting}  
evaluate[B]
  ldc b			where b = 1 if b == true, else 0
\end{lstlisting}
A Boolean constant pushes a 1 on the stack when it is true and a 0 when it is false
  
\begin{lstlisting}
evaluate[(E)] =
  evaluate E
\end{lstlisting}
A parentheses expression simply evaluates the expression within parentheses.
  
\begin{lstlisting}
evaluate[if B then $E_1$ else $E_2$]
  iconst_1
  evaluate B
  if_icmpne	g
  evaluate $E_1$
  goto h
g:
  evaluate $E_2$
h:  
\end{lstlisting}

The conditional is compared to 1. When it is not equal, it jumps to the false expression. The other case evaluates the true expression and jumps over the false expression

\begin{lstlisting}
evaluate[if B then E]
  iconst_1
  evaluate B
  if_icmpne g
  evaluate E
  pop			if type(E) not Void
g:  
\end{lstlisting}

The conditional is compared to 1. When it is not equal, it jumps over the true expression. Whenever the type of the expression is not void, the value needs to be popped off the stack since it is not used anymore.

\begin{lstlisting}
evaluate[S* E] =
  foreach $S_i$ in S:
    execute $S_i$
  evaluate E    if E is not null
\end{lstlisting}
An expression block executes all statements and finally the return expression, if it is given.
 
\begin{lstlisting} 
evaluate[I = E] = 
  evaluate E
  dup
  istore i		where i = variable offset of I
\end{lstlisting}
An assignment evaluates the expression, then duplicates it to allow it to store it to \texttt{I} and return it as a result
  
\begin{lstlisting}  
evaluate[-E] =
  evaluate E
  ineg  
\end{lstlisting}
The unary negate operator first evaluates E, then negates it

\begin{lstlisting}  
evaluate[!E] =
  evaluate E
  iconst_1
  ixor
\end{lstlisting}
The unary not operator xors the expression with 1 to invert it.
  
\begin{lstlisting}  
evaluate[$E_1$ O $E_2$) =
  evaluate $E_1$
  evaluate $E_2$
  call O   
\end{lstlisting}
All binary expressions except \&\& and $\mid\mid$ are evaluated by first evaluating the left and right expressions and then call the specific operator function

\begin{lstlisting}  
evaluate[$E_1$ && $E_2$]
  evaluate $E_1$
  iconst_1
  if_icmpeq g
  iconst_0
  goto i
g:
  evaluate $E_2$
  iconst_1
  if_icmpeq h
  iconst_0
  goto i
h:
  iconst_1
i:
\end{lstlisting}

The and operator is a short circuiting and operator, that is whenever the first expression evaluates to false, the second expression is not evaluated at all. Whenever the first expression matches false it immediately jumps over the second expression. If the first expression is true, then the second expression is also evaluated. Whenever both are true, a 1 is placed on the stack. Whenever at least one expression is false, a 0 is placed on the stack.

\begin{lstlisting}
evaluate[$E_1$ || $E_2$] =
  evaluate $E_1$
  iconst_1
  if_icmpne g
  iconst_1
  goto i
g:
  evaluate $E_2$
  iconst_1
  if_icmpne h
  iconst_1
  goto i
h:
  iconst_0
i:
\end{lstlisting}

The or operator is also short circuiting. Whenever the first expression evaluates to true, the second expression is not evaluated at all. If the first expression evaluates to true it immediately jumps over the second expression. If the first expression is false then it jumps to the second expression and that one is also evaluated. When at least one expression evaluates to true, a 1 is placed on the stack. When neither expressions are true, a 0 is placed on the stack.

\begin{lstlisting}  
evaluate[I] = with I a variable or unknown constants
iload i			where i = variable offset of I
\end{lstlisting}  

A variable expression or constant that is unknown at compile time loads the current value of the variable with the offset of I.

\begin{lstlisting}  
evaluate[I] = with I a known constant
ldc i			where i is the value of the known constant
\end{lstlisting}  

Whenever the value of a variable is already known at compile time, the value is loaded on the stack directly.

\begin{lstlisting}
evaluate[while $E_1$ do $E_2$] =
  goto h
g:
  evaluate $E_2$
  pop           if type($E_2$) not Void
h:
  iconst_1  
  evaluate $E_1$
  if_icmpeq g    
\end{lstlisting}
A while expression first jumps over the body expression. The conditional is evaluated and whenever it is true, it jumps back to the body expression.